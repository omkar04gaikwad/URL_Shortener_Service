AWSTemplateFormatVersion: '2010-09-09'
Description: 'URL Shortener Service - Free Tier Optimized with Lambda, API Gateway, and DynamoDB'

Parameters:
  DomainName:
    Type: String
    Default: 'your-domain.com'
    Description: 'Custom domain for short URLs'
  
  Environment:
    Type: String
    Default: 'dev'
    AllowedValues: ['dev', 'prod']
    Description: 'Environment name (use dev for free tier)'

Resources:
  # DynamoDB Table - Free Tier Optimized
  URLShortenerTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub 'url-shortener-${Environment}'
      BillingMode: PAY_PER_REQUEST  # Free tier: 25GB storage + 25WCU/25RCU
      AttributeDefinitions:
        - AttributeName: short_code
          AttributeType: S
      KeySchema:
        - AttributeName: short_code
          KeyType: HASH
      # Enable TTL for automatic cleanup (free tier optimization)
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      # Point-in-time recovery (free tier includes this)
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      # Tags for cost tracking
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Service
          Value: 'url-shortener'
        - Key: FreeTier
          Value: 'true'

  # Lambda Function - Free Tier Optimized
  URLShortenerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'url-shortener-${Environment}'
      Runtime: python3.9
      Handler: main.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import hashlib
          import json
          import os
          import time
          import boto3
          from botocore.exceptions import ClientError
          
          # Initialize DynamoDB client with cost optimization
          dynamodb = boto3.resource('dynamodb')
          table_name = os.environ.get('DYNAMODB_TABLE', 'url-shortener-table')
          table = dynamodb.Table(table_name)
          
          # In-memory cache for frequently accessed URLs (reduces DynamoDB calls)
          url_cache = {}
          CACHE_SIZE = 100  # Limit cache size for memory efficiency
          
          def shorten_url(long_url):
              long_url_hash = hashlib.sha256(long_url.encode()).hexdigest()[:8]
              try:
                  table.put_item(
                      Item={
                          'short_code': long_url_hash,
                          'long_url': long_url,
                          'created_at': int(time.time()),
                          'clicks': 0
                      },
                      ConditionExpression='attribute_not_exists(short_code)'
                  )
                  if len(url_cache) < CACHE_SIZE:
                      url_cache[long_url_hash] = {
                          'long_url': long_url,
                          'created_at': int(time.time()),
                          'clicks': 0
                      }
                  return long_url_hash
              except ClientError as e:
                  if e.response['Error']['Code'] == 'ConditionalCheckFailedException':
                      return long_url_hash
                  else:
                      print(f"Error storing URL in DynamoDB: {e}")
                      if len(url_cache) < CACHE_SIZE:
                          url_cache[long_url_hash] = {
                              'long_url': long_url,
                              'created_at': int(time.time()),
                              'clicks': 0
                          }
                      return long_url_hash
          
          def redirect_url(short_url):
              if short_url in url_cache:
                  url_cache[short_url]['clicks'] += 1
                  return url_cache[short_url]['long_url']
              try:
                  response = table.get_item(Key={'short_code': short_url})
                  if 'Item' in response:
                      table.update_item(
                          Key={'short_code': short_url},
                          UpdateExpression='SET clicks = clicks + :inc',
                          ExpressionAttributeValues={':inc': 1}
                      )
                      if len(url_cache) < CACHE_SIZE:
                          url_cache[short_url] = response['Item']
                      return response['Item']['long_url']
                  return None
              except ClientError as e:
                  print(f"Error retrieving URL from DynamoDB: {e}")
                  return None
          
          def get_url_stats(short_url):
              if short_url in url_cache:
                  item = url_cache[short_url]
                  return {
                      'short_code': short_url,
                      'long_url': item['long_url'],
                      'created_at': item['created_at'],
                      'clicks': item['clicks']
                  }
              try:
                  response = table.get_item(Key={'short_code': short_url})
                  if 'Item' in response:
                      return {
                          'short_code': short_url,
                          'long_url': response['Item']['long_url'],
                          'created_at': response['Item']['created_at'],
                          'clicks': response['Item']['clicks']
                      }
                  return None
              except ClientError as e:
                  print(f"Error retrieving URL stats from DynamoDB: {e}")
                  return None
          
          def lambda_handler(event, context):
              try:
                  http_method = event.get('httpMethod', '')
                  path = event.get('path', '')
                  
                  if http_method == 'POST' and path == '/shorten':
                      body = json.loads(event.get('body', '{}'))
                      long_url = body.get('url')
                      
                      if not long_url:
                          return {
                              'statusCode': 400,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'URL is required'})
                          }
                      
                      if not long_url.startswith(('http://', 'https://')):
                          long_url = 'https://' + long_url
                      
                      short_code = shorten_url(long_url)
                      domain = os.environ.get('DOMAIN', 'your-domain.com')
                      
                      return {
                          'statusCode': 200,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({
                              'shortCode': short_code,
                              'longUrl': long_url,
                              'shortUrl': f"https://{domain}/{short_code}",
                              'message': 'URL shortened successfully (Free Tier Optimized)'
                          })
                      }
                  
                  elif http_method == 'GET' and path.startswith('/redirect/'):
                      path_params = event.get('pathParameters', {})
                      short_code = path_params.get('shortCode')
                      
                      if not short_code:
                          return {
                              'statusCode': 400,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'Short code required'})
                          }
                      
                      long_url = redirect_url(short_code)
                      if not long_url:
                          return {
                              'statusCode': 404,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'Short code not found'})
                          }
                      
                      return {
                          'statusCode': 302,
                          'headers': {'Location': long_url},
                          'body': ''
                      }
                  
                  elif http_method == 'GET' and path.startswith('/stats/'):
                      path_params = event.get('pathParameters', {})
                      short_code = path_params.get('shortCode')
                      
                      if not short_code:
                          return {
                              'statusCode': 400,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'Short code required'})
                          }
                      
                      stats = get_url_stats(short_code)
                      if not stats:
                          return {
                              'statusCode': 404,
                              'headers': {'Content-Type': 'application/json'},
                              'body': json.dumps({'error': 'Short code not found'})
                          }
                      
                      return {
                          'statusCode': 200,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps(stats)
                      }
                  
                  elif http_method == 'GET' and path == '/':
                      return {
                          'statusCode': 200,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({
                              'message': 'URL Shortener Service - Free Tier Optimized',
                              'endpoints': {
                                  'shorten': 'POST /shorten',
                                  'redirect': 'GET /redirect/{shortCode}',
                                  'stats': 'GET /stats/{shortCode}'
                              },
                              'free_tier_info': {
                                  'lambda_requests': '1M free per month',
                                  'dynamodb_storage': '25GB free per month',
                                  'dynamodb_requests': '25WCU/25RCU free per month',
                                  'api_gateway': '1M free API calls per month'
                              }
                          })
                      }
                  
                  else:
                      return {
                          'statusCode': 404,
                          'headers': {'Content-Type': 'application/json'},
                          'body': json.dumps({'error': 'Endpoint not found'})
                      }
              
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'headers': {'Content-Type': 'application/json'},
                      'body': json.dumps({'error': str(e)})
                  }
      
      Environment:
        Variables:
          DOMAIN: !Ref DomainName
          ENVIRONMENT: !Ref Environment
          DYNAMODB_TABLE: !Ref URLShortenerTable
      
      # Free tier optimized settings
      Timeout: 15  # Reduced from 30s to save costs
      MemorySize: 128  # Reduced from 256MB to save costs
      # Enable function URL for direct testing (free tier includes this)
      FunctionUrlConfig:
        AuthType: NONE
        Cors:
          AllowCredentials: false
          AllowHeaders: "'*'"
          AllowMethods: "'*'"
          AllowOrigins: "'*'"

  # Lambda Execution Role with minimal permissions (security best practice)
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                Resource: !GetAtt URLShortenerTable.Arn

  # API Gateway - Free Tier Optimized
  URLShortenerApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'url-shortener-api-${Environment}'
      Description: 'API Gateway for URL Shortener Service (Free Tier Optimized)'
      EndpointConfiguration:
        Types:
          - REGIONAL  # Regional endpoints are cheaper than edge-optimized

  # API Gateway Resources
  ApiRoot:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref URLShortenerApi
      ParentId: !GetAtt URLShortenerApi.RootResourceId
      PathPart: ''

  ShortenResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref URLShortenerApi
      ParentId: !GetAtt URLShortenerApi.RootResourceId
      PathPart: 'shorten'

  RedirectResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref URLShortenerApi
      ParentId: !GetAtt URLShortenerApi.RootResourceId
      PathPart: 'redirect'

  ShortCodeResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref URLShortenerApi
      ParentId: !Ref RedirectResource
      PathPart: '{shortCode}'

  StatsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref URLShortenerApi
      ParentId: !GetAtt URLShortenerApi.RootResourceId
      PathPart: 'stats'

  StatsShortCodeResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref URLShortenerApi
      ParentId: !Ref StatsResource
      PathPart: '{shortCode}'

  # API Gateway Methods
  GetRootMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref URLShortenerApi
      ResourceId: !Ref ApiRoot
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${URLShortenerFunction.Arn}/invocations'

  PostShortenMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref URLShortenerApi
      ResourceId: !Ref ShortenResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${URLShortenerFunction.Arn}/invocations'

  GetRedirectMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref URLShortenerApi
      ResourceId: !Ref ShortCodeResource
      HttpMethod: GET
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.shortCode: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${URLShortenerFunction.Arn}/invocations'

  GetStatsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref URLShortenerApi
      ResourceId: !Ref StatsShortCodeResource
      HttpMethod: GET
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.shortCode: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${URLShortenerFunction.Arn}/invocations'

  # Lambda Permission for API Gateway
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref URLShortenerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${URLShortenerApi}/*/*'

  # API Gateway Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - GetRootMethod
      - PostShortenMethod
      - GetRedirectMethod
      - GetStatsMethod
    Properties:
      RestApiId: !Ref URLShortenerApi
      StageName: !Ref Environment

Outputs:
  ApiUrl:
    Description: 'API Gateway URL'
    Value: !Sub 'https://${URLShortenerApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiUrl'

  LambdaFunctionUrl:
    Description: 'Direct Lambda Function URL (Free Tier Feature)'
    Value: !GetAtt URLShortenerFunction.FunctionUrl
    Export:
      Name: !Sub '${AWS::StackName}-FunctionUrl'

  LambdaFunctionArn:
    Description: 'Lambda Function ARN'
    Value: !GetAtt URLShortenerFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaArn'

  DynamoDBTableName:
    Description: 'DynamoDB Table Name'
    Value: !Ref URLShortenerTable
    Export:
      Name: !Sub '${AWS::StackName}-TableName'

  ApiId:
    Description: 'API Gateway ID'
    Value: !Ref URLShortenerApi
    Export:
      Name: !Sub '${AWS::StackName}-ApiId'

  FreeTierInfo:
    Description: 'Free Tier Usage Information'
    Value: !Sub |
      Free Tier Limits:
      - Lambda: 1M requests/month
      - DynamoDB: 25GB storage + 25WCU/25RCU
      - API Gateway: 1M API calls/month
      - Data Transfer: 15GB/month
    Export:
      Name: !Sub '${AWS::StackName}-FreeTierInfo'
